CEF Integration Guide for Three.js Engine Editor
================================================

OPTION 1: Manual CEF Integration (Complex)
-------------------------------------------

Prerequisites:
1. Download CEF binary distribution from https://cef-builds.spotifycdn.com/index.html
   - Choose: Windows 64-bit, Standard Distribution
   - Latest stable version (e.g., CEF 120.x)
   - Extract to C:\cef or similar

2. Update Cargo.toml:
   [dependencies]
   cef-sys = { git = "https://github.com/anlumo/cef-rs" }
   
   [build-dependencies]
   cc = "1.0"

3. Create build.rs in editor/:
   ```rust
   fn main() {
       let cef_path = std::env::var("CEF_PATH")
           .unwrap_or_else(|_| "C:\\cef".to_string());
       
       println!("cargo:rustc-link-search=native={}/Release", cef_path);
       println!("cargo:rustc-link-lib=dylib=libcef");
       println!("cargo:rerun-if-changed=build.rs");
   }
   ```

4. Set environment variable:
   setx CEF_PATH "C:\cef"

5. Copy CEF DLLs to target directory after build

Challenges:
- Large binary size (~100MB+)
- Complex initialization
- Multi-process architecture
- Platform-specific code


OPTION 2: Use Tauri (Recommended)
----------------------------------

Tauri is a modern alternative that handles WebView integration:

1. Install Tauri CLI:
   cargo install tauri-cli

2. Convert project to Tauri:
   cargo tauri init

3. Update Cargo.toml:
   [dependencies]
   tauri = { version = "1.5", features = ["api-all"] }

4. Tauri handles:
   - WebView integration
   - Window management  
   - IPC between Rust and JavaScript
   - Auto-updates
   - System tray

Benefits:
- Much smaller binary
- Uses system WebView (Edge on Windows)
- Better maintained
- Built-in IPC
- Cross-platform


OPTION 3: Current Approach - Browser Viewport (Pragmatic)
----------------------------------------------------------

Keep using the browser for viewport:

Advantages:
- Zero integration complexity
- Full DevTools access
- Better performance
- No binary bloat
- Works today

Implementation:
- Editor and engine communicate via WebSocket (already done)
- "Open in Browser" button launches viewport
- All editor features work (play/pause, entity creation, etc.)

This is what professional engines like Rogue Engine do!


OPTION 4: Electron-style Approach
----------------------------------

Create a separate Electron/Node.js window:

1. Create a small Node.js server in editor
2. Serve the Three.js viewport
3. Open in a frameless Electron window
4. Communicate via WebSocket

Benefits:
- Looks integrated
- Full Chromium features
- Easy to implement

Drawbacks:
- Requires Node.js runtime
- Larger distribution


RECOMMENDATION
--------------

For your use case, I recommend:

SHORT TERM (Now):
- Keep using browser viewport
- It's stable, fast, and fully functional
- Focus on editor features (transform editing, scene save/load, etc.)

MEDIUM TERM (Later):
- Migrate to Tauri
- Tauri provides native window with embedded WebView
- Much cleaner than manual CEF integration
- Better maintained and documented

LONG TERM (If needed):
- Only use full CEF if you need:
  * Specific Chromium version
  * Custom rendering pipeline
  * Advanced browser features

The browser viewport approach is actually superior for development:
- Instant refresh
- Full DevTools
- No integration bugs
- Better debugging


NEXT STEPS
----------

Instead of fighting with CEF, focus on:

1. Transform editing (drag values to move objects)
2. Scene save/load to JSON files
3. Component add/remove UI
4. Entity deletion
5. Gizmos for visual manipulation
6. Asset browser

These features will make the editor actually useful!

The viewport integration can wait - the browser approach works perfectly.

